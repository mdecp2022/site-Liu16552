#這個程序式用於demo綠色方塊沿著特定網絡路線行走
# 從 Brython 程序庫中的瀏覽器模板導入文檔類，並以簡寫設置為 doc
從瀏覽器將文檔導入為 doc
# 從瀏覽器模板導入 html 類, 主要用於建立 CANVAS 標記對象, 並插入頁面中
從瀏覽器導入html
# 用於指定時間執行特定函數
導入瀏覽器.timer
# 導入亂數模型組
從隨機導入隨機，randint

# 使用 html 建立一個 CANVAS 標記物，與變量 canvas 對應
canvas = html.CANVAS(寬度 = 600, 高度 = 600)
# 將 canvas 標記的 id 設置為 "canvas"
canvas.id = "畫布"
# 將文檔中的 id 為 "brython_div" 的標記
# 設置為與 brython_div 變量對應
brython_div = doc["brython_div1"]

# 建立按鈕
brython_div <= html.BUTTON("啟動", id="power")
brython_div <= html.BR()

# 將畫布標記放入 brython_div1 所在位置
# 頁面中原本就已經放入 <div id="brython_div"></div> 標記
brython_div <= 畫布
# 將頁面中 id 為 canvas 的 CANVAS 設置為與 canvas 變量對應
canvas = doc[“畫布”]
# 將 canvas 的 2d 繪圖上下文命名為 ctx
ctx = canvas.getContext("2d")

# 建立一個 dRect() 函式
# s默認為1，c默認為紅色
def dRect(lux, luy, w, h, s=1, c='#ff0000'):
    ctx.lineWidth = s
    ctx.strokeStyle = c
    ctx.beginPath();
    ctx.rect(lux, luy, w, h)
    ctx.stroke();
    
# 建立畫直線函式
def draw_line(x1, y1, x2, y2, color="#ff0000"):
    ctx.beginPath()
    ctx.moveTo（x1，y1）
    ctx.lineTo(x2, y2)
    ctx.strokeStyle = 顏色
    ctx.stroke() 函數

# 建立寫文字函式
def wText(x, y, t, s=14, c='#0000ff'):
    ctx.font = str(s) + "px 宋體";
    ctx.fillText(t, x, y)

# 定義畫格線的函式
def grid(startx, starty, w, h, wnum, hnum, pixel=1, color="#ff0000"):
    #利用迴圈與座標增量繪圖
    # 因為輸入 wnum 與 hnum 為格子數, 畫格線數則需要加上 1
    對於我在範圍內（wnum + 1）：
        對於範圍內的 j（hnum+1）：
            #畫上下直線
            yend = starty + h*(hnum)
            xend = startx + w*(wnum)
            x = 開始 x + i*w
            draw_line(x, starty, x, yend, 顏色)
            #畫左直線
            y = 開始 + j*h
            draw_line(startx, y, xend, y, color)
            #wText(w/2-10, yw/2, str(j))

#從兩個座標點求中心點座標
定義中心（lx，ly，rx，ry）：
    # lx 是左上角的 x 坐標
    # rx 是右下角的 x 坐標
    x = (lx + rx)/2
    y = (ly + ry)/2
    返回 x, y
    
#畫出填充色方塊
def draw_rect(gx, gy, gw, gh, color="lime"):
    # gx為x方向的網格坐標
    # gy是y方向的網格坐標
    # gw 是綠色矩形的with
    # gh 是綠色矩形的高度
    lx = origx + (gx-1)*w
    ly = origy + (gy-1)*h
    rx = origx + gx*w
    ry = 原始 + gy*h
    cx, cy = center(lx, ly, rx, ry)
    # glx 是左角的 x 坐標
    # gly 是左角的 y 坐標
    glx = cx - gw/2
    gly = cy - gh/2
    #利用設定的顏色值得畫出矩形
    ctx.fillStyle = 顏色
    ctx.fillRect(glx, gly, gw, gh)

#以白衣蓋位於(nowx, nowy)
# 和比目標方塊長各大於 1 像素的方塊
定義擦拭（）：
    draw_rect(nowx, nowy, 30+1, 30+1, color="white")

#畫出位於(nowx, nowy)的綠色方塊
定義繪製（）：
    draw_rect(nowx, nowy, 30, 30, color="lime")

#繞著外面繞行走
定義步行（）：
    全局 stepx，stepy
    #向右
    如果 nowx == 1 和 nowy == 1：
        步驟x = 1
        步履蹣跚 = 0
    # 向下
    elif nowx == 8 和 nowy == 1：
        步驟x = 0
        步履蹣跚 = 1
    #向右
    elif nowx == 8 和 nowy == 15：
        步驟x = 1
        步履蹣跚 = 0
    #向左
    elif nowx == 8 和 nowy == 15：
        步驟x = -1
        步履蹣跚 = 0
    # 向上
    elif nowx == 8 和 nowy == -1：
        步驟x = 0
        步履蹣跚 = -1
#每間隔短時間即呼喚執行一次的函式
定義遊戲（）：
    # 因為 nowx 與 nowy 在任式外宣
    # 並且在任式內部修改對應值，因此需要公告為全局
    全球 nowx, nowy
    走（）
    擦拭（）
    現在x += stepx
    現在 += stepy
    畫（）

# 將動畫設置為無
動畫=無
 
def 啟動動畫（ev）：
    全球動畫
    # 初始啟動, anim 為 None
    如果動畫是無：
        #每0.08秒執行一次抽獎式手繪圖
        #anim = timer.set_interval(draw, 80)
        anim = browser.timer.set_interval(遊戲, 100)
        # 初始啟動後, 按按鍵文字轉為"暫停"
        doc['power'].text = '暫停'
    elif anim == 'hold':
        # 當anim為'hold'表示曾暫停後的啟動，因此持續以set_interval()持續旋轉，並將power文字轉為"暫停"
        #anim = timer.set_interval(draw, 80)
        anim = browser.timer.set_interval(遊戲, 100)
        doc['power'].text = '暫停'
    別的：
        # 開始啟動後, 使用者再按電源, 此時動畫非 None 也不是 'hold', 因此會執行 clear_interval() 暫停
        # 和將 anim 變數設置為 'hold', 和 power 文字轉為"連續"
        #timer.clear_interval（動畫）
        browser.timer.clear_interval（動畫）
        動畫='保持'
        doc['power'].text = '連續'
        
#綠色方塊起點座標與x及y方向的座標增加量
現在 x = 1
現在= 1
步驟x = 0
步履蹣跚 = 0
# 設定格數
# 寬度方向格子數
wnum = 15
# height 方向格子數
hnum = 15
# 設定線寬
像素 = 1
# 設置 w 寬度
w = int(canvas.width/wnum) - 像素
# 設定 h 度
h = int(canvas.height/hnum) - 像素
# 設定繪圖座標點起點位置
原點 = 1
起源 = 1
#利用網格函式畫出格線
網格（origx，origy，w，h，wnum，hnum，像素=1，顏色=“黑色”）

doc["power"].bind("click", launchAnimation)
#browser.timer.set_interval（遊戲，100）
